<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://abhimanyu08.github.io/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://abhimanyu08.github.io/blog/" rel="alternate" type="text/html" /><updated>2020-05-23T05:51:38-05:00</updated><id>https://abhimanyu08.github.io/blog/feed.xml</id><title type="html">Abhimanyu</title><subtitle>A blog where I write about things I learn on my self-taught journey in the field of Artificial Intelligence</subtitle><entry><title type="html">What Does Label Smoothing Do?</title><link href="https://abhimanyu08.github.io/blog/deep-learning/2020/05/17/final.html" rel="alternate" type="text/html" title="What Does Label Smoothing Do?" /><published>2020-05-17T00:00:00-05:00</published><updated>2020-05-17T00:00:00-05:00</updated><id>https://abhimanyu08.github.io/blog/deep-learning/2020/05/17/final</id><content type="html" xml:base="https://abhimanyu08.github.io/blog/deep-learning/2020/05/17/final.html">&lt;!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2020-05-17-final.ipynb
--&gt;

&lt;div class=&quot;container&quot; id=&quot;notebook-container&quot;&gt;
        
    
    
&lt;div class=&quot;cell border-box-sizing code_cell rendered&quot;&gt;

&lt;/div&gt;
    

&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;h2 id=&quot;Introduction&quot;&gt;Introduction&lt;a class=&quot;anchor-link&quot; href=&quot;#Introduction&quot;&gt; &lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Label smoothing was introduced by Szegedy et.al in the paper &lt;a href=&quot;https://arxiv.org/abs/1512.00567&quot;&gt;Rethinking the Inception Architecture for Computer Vision&lt;/a&gt;. Since then, this trick has been used in many papers to improve the accuracy of various architectures. Although being widely used, there was less insight as to why this technique helps the model to perform better, but the paper by Rafael MÃ¼ller et.al &lt;a href=&quot;https://arxiv.org/abs/1906.02629v2&quot;&gt;When does Label Smoothing Help?&lt;/a&gt; answers the question of &quot;What does label smoothing do?&quot; and &quot;Why does it help the model?&quot;. This blog post is an attempt to explain the main result of the paper.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;h2 id=&quot;1.-What-Is-Label-Smoothing?&quot;&gt;1. What Is Label Smoothing?&lt;a class=&quot;anchor-link&quot; href=&quot;#1.-What-Is-Label-Smoothing?&quot;&gt; &lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Generally, in a classification problem, our aim is to maximize the log-likelihood of our ground-truth label. In other words, we want our model to assign maximum probability to the true label given the parameters and the input i.e we want ${P(y\mid x,\theta)}$ to be high, where the ${y}$ is known beforehand. We motivate our model to achieve this by minimizing the cross-entropy loss between the predictions our model outputs and the ground truth labels. Cross entropy loss is defined by the equation:
${L(y,\hat y)=-\sum_{i=1}^{n} y_{i} \times log(\hat y_{i}) }$ where n is the number of classes, ${y_{i}}$ is 1 if image belongs to class ${i}$ and 0 otherwise, and ${\hat y_{i}}$ is probability of ${y_{i}}$ being 1. Don't be intimidated by the daunting equation and jargon because in reality the calculation of loss is very easy. Suppose you build a model for task of image-classification where an image can belong to one of the 3 classes. For every image as the input the model outputs a 3-dimensional vector. Let's say for a particular image the model's normalised output is 
${\hat y = [0.2, 0.7,0.1]}$ and the image belongs to category 2. Therefore, the target vector for that image will be ${y = [0,1,0]}$. The loss for this image will be ${-(0\times \log 0.2 + 1\times \log 0.7 + 0\times \log 0.1) = -\log 0.7=0.35}$ which is low because our model assigns high probability to groud truth label. If instead our predictions are ${
\hat y=[0.8,0.1,0.1]}$, then the loss will be ${-\log 0.1=2.3}$ which is high because now our model assigns low probability to ground-truth label.&lt;/p&gt;
&lt;p&gt;There is little more to how the normalised predictions of the model are calculated. The model's predictions are calulated by applying the Softmax activation on the last layer's output. The model outputs a 3-dimensional vector and each of the element of the vector is called 'logit'. For the logits to represent a valid probability distribution over the classes they should sum to 1. This is accomplished by passing the logits through a softmax layer. Let's say the output vector for a certain image as input is ${z = [z_{1}, z_{2},...,z_{n}]}$ then the predictions are calculated as ${\hat y = \text Softmax \left(z \right) = \large [\frac {e^{z_{1}}}{\sum_{i=1}^{n} e^{z_{i}}}, \frac {e^{z_{2}}}{\sum_{i=1}^{n} e^{z_{i}}},...,
\frac {e^{z_{n}}}{\sum_{i=1}^{n} e^{z_{i}}}]}$.${(Eq\,1.1)}$
Notice that sum of all the elements of ${\hat y}$ is 1. Suppose the ground truth label for the image is 2, then the target vector is ${[0,1,0,0,....0]}$ (The length of target vector is n as well). Thus, the Cross-entropy loss for this image, in it's full glory is written as ${\text loss\left(y,z\right) = -1 \times \normalsize \log \frac {e^{z_{2}}}{\sum_{i=1}^{n} e^{z_{i}}} = \log {\sum_{i=1}^{n} e^{z_{i}}} - z_{2}}$. Minimising this loss encourages ${z_{2}}$ to be as high as possible while ${z_{i}}$ for ${i\ne2}$ are encouraged to be low. Szegedey et.al highlight two problems with this approach:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The first problem with this approach is that model becomes over-confident for it's predictions as it learns to assign nearly 100% probability to the ground-truth label. Szegedy et. al argue that this can lead to overfitting and model may not be able to generalize well. Intuitively this makes sense. for.eg Let's say our dataset contains two symantically similar classes class1 and class2(&lt;a href=&quot;https://www.robots.ox.ac.uk/~vgg/data/pets/&quot;&gt;pets dataset&lt;/a&gt; has plenty of those). Unfortunately our dataset contains many instances of class1 but relatively less instances of class2. Suppose image1 belongs to class1 and image2 to other. Because these images are very similar, the output logits of these images would be very similar. Our over-confident model may assign class1 to the image2 with high confidence(close to 100% probability) and this can incur heavy validation loss.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The other problem with this approach is the vanishing gradient. The gradient of our loss w.r.t logit of correct class label k is ${\large \frac {e^{z_{k}}}{\sum_{i=1}^{n} e^{z_{i}}}-1}$ and w.r.t other logits is ${\large \frac {e^{z_{i}}}{\sum_{i=1}^{n} e^{z_{i}}}}$. Minimising the cross-entropy loss leads to logit corresponding to correct class to be much higher than other logits. This leads to vanishing of gradients of loss w.r.t other logits and thus it hinders the model's ability to adapt.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;What can we do to counteract these two problems? Szegedy et.al suggest that we shouldn't provide sparse one-hot encoded vectors as target. Instead we should &quot;smoothen&quot; them. This is done by replacing the probability distribution over labels from dirac delta distribution to a linear combination of dirac delta distribution and a uniform distribution. This may sound incredibly complex to hear but in reality is very easy to implement. Let's define what the above jargon means.&lt;/p&gt;
&lt;p&gt;Dirac delta function denoted by ${\delta _{i,l}}$ is a function which is 1 for ${i=l}$ and 0 everywhere else. If an image has class ${l=3}$ as it's label and there are ${k=4}$ classes in total, then the target vector for that image has the probability distribution ${\delta _{i,3}}$ for ${i=1\,to\,k}$. ${i}$ represents index of the target vector (I haven't used 0 indexing) and therefore the target vector is ${[0,0,1,0]}$. Notice that ${\delta _{i,l}}$ is a valid probability distribution as it sums to 1 over it's domain. A uniform distribution is a distribution which has a constant value over it's domain. Let's say our domain consists of ${\{x\epsilon[1,4]: x\epsilon I\}}$. This is read as x belongs to 1 to 4 both included such that x is an integer. So, ${x\epsilon \{1,2,3,4\}}$. Uniform distribution over this domain is denoted as ${U\left(x\right)}$. ${\therefore U\left(1\right) = U\left(2\right) = U\left(3\right) = U\left(4\right) = c}$. The sum over the domain i.e ${\sum_{i=1}^{4} U(i)}$ is 4c. For ${U(x)}$ to be a valid probability distribution ${4c}$ should equal to 1. ${\therefore c=0.25}$. More generally we can say that if there are ${k}$ points in our domain, then uniform distribution over the domain would be ${U(i)=\frac{1}{k}}$ where ${i}$ is any point in the domain.&lt;/p&gt;
&lt;p&gt;Let's denote the distribution over our labels for a particular image as ${q\left(i\right)}$ where ${i=1\,to\,k}$. ${k}$ denotes the total no of classes and ${l}$ denotes the true label for the image. Generally, ${q\left(i\right) = \delta _{i,l}}$. Szegedy et. al propose to replace ${\delta _{i,l}}$ with ${(1-\varepsilon)\delta _{i,l} + \varepsilon U\left(i\right)\,for\,i=1\,to\,k}$ where ${\varepsilon}$ is a hyperparameter. As explained above, value of ${U\left(i\right)}$ should be ${\frac {1}{k}\,for\,i=1\,to\,k}$. Then, our new distribution over labels is ${q'(i) = (1-\varepsilon)\delta _{i,l} + \frac{\varepsilon}{k}}$ $(Eq\,1.1)$. Let's see how to do this using an example.&lt;/p&gt;
&lt;p&gt;Suppose distribution over target labels of an image say image1 for a classification task which has ${k=4}$ classes is ${q\left(i,2\right)=\delta_{i,2}\, for \,i = 1\,to\,k}$. ${i}$ here represents index of target vector. Thus, target vector will be ${y^{h}=[0,1,0,0]}$. Then, our new distribution over labels according to ${Eq\,1.1}$ is
${q'\left(i,2\right) = (1-\varepsilon)\delta _{i,2} + \frac{\varepsilon}{4}}$ for ${i=1\,to\,4}$. Subsequently, smoothened target vector ${y^{l}}$ will be ${[\frac{\varepsilon}{4},(1-\varepsilon)+\frac{\varepsilon}{4},\frac{\varepsilon}{4},\frac{\varepsilon}{4}]}$ = ${[0.25\varepsilon, 1-\varepsilon+0.25\varepsilon, 0.25\varepsilon,0.25\varepsilon]}$. If ${\varepsilon = 0.2}$,then ${y^{l} =[0.05,0.85,0.05,0.05]}$. Notice that elements of new smoothened label vector still sum to 1, which confirms that ${(1-\varepsilon)\delta _{i,l}+\varepsilon U\left(i\right)}$ is a valid probability distribution over the labels.&lt;/p&gt;
&lt;p&gt;Let's see what difference does it make to change the labels in the way shown above. Suppose our model outputs the prediction vector ${p_{1}=[0.05,0.9,0.03,0.02]}$ for image1. So the model is really confident that this image has label 2 which is a good thing since this image really does has label 2. The loss with smoothened labels ${y^{l}}$ will be ${L(y^{l},p_{1})= -(0.05\log 0.05+0.85\log0.9+0.05\log0.03+0.05\log0.02)= 0.61}$. Now suppose our model didn't output ${p_{1}}$ but ${p_{2}=[0.01,0.79,0.15,0.5]}$. In this case it is less sure that the image has label 2. Loss will be ${L(y^{l},p_{2})= -(0.05\log0.01+0.85\log0.79+0.05\log0.15+0.05\log0.5)=0.56}$ which is less than the loss with ${p_{1}}$ ! This goes on to show that smooth labels want the model to be confident about it's predictions but not over-confident.&lt;/p&gt;
&lt;p&gt;Intuitively we can think of label smoothing as a process to reduce the confidence of model in it's ground truth labels.The ground truth labels may sometimes be awry owing to errors in data labelling or data collection process. Label smoothing can make the model robust against those incorrect labels.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;h2 id=&quot;2.-Implementation-In-Code&quot;&gt;2. Implementation In Code&lt;a class=&quot;anchor-link&quot; href=&quot;#2.-Implementation-In-Code&quot;&gt; &lt;/a&gt;&lt;/h2&gt;&lt;p&gt;To implement label smoothing, we don't change every label individually but we define a new loss function. Loss function is still Cross-entropy loss but our target vector for every image changes. Our new target vector for a particular image is ${y^{l} = [\frac {\varepsilon}{k},\frac {\varepsilon}{k},...,(1 - \varepsilon) + \frac{\varepsilon}{k},\frac {\varepsilon}{k},\frac {\varepsilon}{k},...k times]}$. Let's assume the image belongs to class ${j}$. Normal one hot encoded target label will have 1 at j position and 0 everywhere else. Let's denote it as ${y^{h}}$. So, ${y^{h} = [0,0,0,...,1,0,...0]}$.&lt;/p&gt;
&lt;p&gt;The loss with ${y^{h}}$ is ${L(y^{h},\hat y)= -\log \hat y_{j}}$. ${Eq\,2.1}$&lt;/p&gt;
&lt;p&gt;The loss with new smoothened labels is ${L\left(y^{l},\hat y\right) = \sum_{i=1}^{k} -y_{i}^{l}\log \hat y_{i}}$ = ${- \left( \frac {\varepsilon}{k}\log\hat y_{1} +...+ \left(1-\varepsilon+ \frac{\varepsilon}{k}\right)\log\hat y_{j}+\frac {\varepsilon}{k}\log\hat y_{j+1}+...+\frac {\varepsilon}{k}\log\hat y_{k}\right)}$. We can rewrite this as ${L\left(y^{l},\hat y\right) = -\left(1-\varepsilon\right)\times\log\hat y_{j} - \frac{\varepsilon}{k}\times\left(\sum_{i=1}^{k} \log\hat y_{i}\right)}$. Eagle eyed reader can notice that the term which is multiplied by ${\left(1 - \varepsilon\right)}$ is the cross-entropy loss calculated with one hot encoded target vector. Therefore, ${L\left(y^{l},\hat y\right) = \left(1-\varepsilon\right)L\left(y^{h},\hat y\right)-\frac{\varepsilon}{k}\left(\sum_{i=1}^{k} \log\hat y_{i}\right)}$. ${Eq\,2.2}$&lt;/p&gt;
&lt;p&gt;So, we only need to modify the loss function of our model and we are good to go. The implementation of this in code is shown below. The code snippet below uses Pytorch framework and implementation is copied from the &lt;a href=&quot;https://www.fast.ai/&quot;&gt;fast.ai&lt;/a&gt; course.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
    
    
&lt;div class=&quot;cell border-box-sizing code_cell rendered&quot;&gt;
&lt;details class=&quot;description&quot; open=&quot;&quot;&gt;
      &lt;summary class=&quot;btn btn-sm&quot; data-open=&quot;Hide Code&quot; data-close=&quot;Show Code&quot;&gt;&lt;/summary&gt;
        &lt;p&gt;&lt;div class=&quot;input&quot;&gt;

&lt;div class=&quot;inner_cell&quot;&gt;
    &lt;div class=&quot;input_area&quot;&gt;
&lt;div class=&quot; highlight hl-ipython3&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;#collapse-show&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;torch&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lin_comb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;factor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;sd&quot;&gt;&amp;#39;&amp;#39;&amp;#39;This function calculates linear combination of &lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;    two quantities a1 and a2 where the respective&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;    coeffecients are factor and (1-factor)&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;factor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reduce_loss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reduction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;mean&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;sd&quot;&gt;&amp;#39;&amp;#39;&amp;#39;We need this function because we generally calcualate &lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;    losses for a batch of images and take the mean or sum all the &lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;    losses. But throughout this blog we input only a single image &lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;    in the model so you can ignore this fuction and just assume &lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;    that this funtion does nothing. for.eg reduce_loss(2)=2&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mean&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reduction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;mean&amp;#39;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reduction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;sum&amp;#39;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt;    

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LabelSmoothing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fm&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reduction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;mean&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;fm&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#factor for linear combination&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reduction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reduction&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#You can safely ignore this&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pred&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;targ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;#this line of code implements Eq 1.1&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log_softmax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pred&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dim&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
        &lt;span class=&quot;c1&quot;&gt;#this line of code calculates the sum part of second term in Eq 2.2&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reduce_loss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reduction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;#this line of code calculates Eq 2.1&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;l2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nll_loss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;targ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reduction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reduction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;#finally this line implements Eq 2.2&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lin_comb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pred&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

    &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;
    &lt;/details&gt;
&lt;/div&gt;
    

&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;h2 id=&quot;3.-How-And-Why-Does-It-Work?&quot;&gt;3. How And Why Does It Work?&lt;a class=&quot;anchor-link&quot; href=&quot;#3.-How-And-Why-Does-It-Work?&quot;&gt; &lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Label smoothing goes against the conventional practice of maximising the likelihood of ground truth label. Instead, it punishes the model if the logits which don't correspond to correct label get too low. This can be seen by the second term in equation of loss mentioned above i.e ${-\frac{\varepsilon}{k}\left(\sum_{i=1}^{k} \log\hat y_{i}\right)}$. We can see that if ${\hat y_{i}\, for\, i = {1,2,...,k}}$ go too close to 0 then the loss goes up (${\log}$ of something close to 0 is a large negative number). In contrast, maximising the likelihood of one-hot encoded ground-truth label encourages the logits that don't correspond to correct label to go as low as possible. With smooth labels ${y^{l}}$ our aim is to maximise ${P(y^{l}\mid x,\theta)}$. Let's see why maximising the likelihood of smooth labels instead of maximising the likelihood of one-hot encoded labels is benificial for our model.&lt;/p&gt;
&lt;h3 id=&quot;Calculating-Loss-Without-Label-Smoothing&quot;&gt;Calculating Loss Without Label Smoothing&lt;a class=&quot;anchor-link&quot; href=&quot;#Calculating-Loss-Without-Label-Smoothing&quot;&gt; &lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Let's imagine that we have a task to build a model for image classification task where each image can have one of three labels. This means our model will output a 3-dimensional vector containing our three logits. Assume that penultimate layer of the model has 4 activations. We put in an image in this model which has a target vector ${y^{h} = [0,1,0]^{T}}$. The penultimate layer's activations are ${X = [x_{1},x_{2},x_{3},x_{4}]^{T}}$, the last layer's outputs are ${Z = [z_{1},z_{2},z_{3}]^{T}}$ (A single vector is conventionally written as column vector, therefore, ${X}$, ${Z}$ and ${y^{h}}$ are written as transpose of row vectors). ${Z}$ is calculated from the penultimate layer's activation using the equation ${Z = W\star X}$ (${\star}$ here denotes matrix multiplication). Bias is ignored for sake of brevity. ${W}$ is the weight matrix connecting penultimate layer and output layer. ${W = \left[
         \begin{array}{ccc}
         w_{11} &amp;amp; w_{12} &amp;amp; w_{13} &amp;amp; w_{14}          \\
         w_{21} &amp;amp; w_{22} &amp;amp; w_{23} &amp;amp; w_{24}\\
         w_{31} &amp;amp; w_{32} &amp;amp; w_{33} &amp;amp; w_{34}
        \end{array}
    \right]}$. Shortly weight matrix can be written as ${W = [w_{1},w_{2},w_{3}]^{T}}$ where ${w_{i} = [w_{i1},w_{i2},w_{i3},w_{i4}]}$. The output vector ${Z}$ is calculated as ${W\star X = \left[
         \begin{array}{ccc}
         w_{11}\times x_{1} &amp;amp; w_{12}\times x_{2} &amp;amp; w_{13}\times x_{3} &amp;amp; w_{14}\times x_{4}          \\
         w_{21}\times x_{1} &amp;amp; w_{22}\times x_{2} &amp;amp; w_{23}\times x_{3} &amp;amp; w_{24}\times x_{4}\\
         w_{31}\times x_{1} &amp;amp; w_{32}\times x_{2} &amp;amp; w_{33}\times x_{3} &amp;amp; w_{34}\times x_{4}
        \end{array}
    \right]}$. In short this can be written as ${Z = \left[\begin{array}{ccc}
         z_{1}          \\
         z_{2}           \\
         z_{3}
        \end{array}
    \right] = \left[
         \begin{array}{ccc}
         w_{1}X^{T}          \\
         w_{2}X^{T}           \\
         w_{3}X^{T}
        \end{array}
    \right]}$ where ${w_{i}X^{T}}$ denotes inner product between ${w_{i}}$ and ${X^{T}}$. ${Z}$ is a vector of logits and is un-normalised. To get our prediction vector we would have to normalise this by passing ${Z}$ through a softmax layer. Our prediction vector would be ${\hat y = \left[
         \begin{array}{ccc}
         \frac {e^{w_{1}X^{T}}}{e^{w_{1}X^{T}}+e^{w_{2}X^{T}}+e^{w_{3}X^{T}}}          \\
         \frac {e^{w_{2}X^{T}}}{e^{w_{1}X^{T}}+e^{w_{2}X^{T}}+e^{w_{3}X^{T}}}           \\
         \frac {e^{w_{3}X^{T}}}{e^{w_{1}X^{T}}+e^{w_{2}X^{T}}+e^{w_{3}X^{T}}}
        \end{array}
    \right]}$. As given before, our target vector is ${y^{h} = [0,1,0]^{T}}$. So, our cross-entropy loss will be ${L\left(y^{h},\hat y\right) = -\log \left(\frac {e^{w_{2}X^{T}}}{e^{w_{1}X^{T}}+e^{w_{2}X^{T}}+e^{w_{3}X^{T}}}\right)}$. For preserving our sanity let's denote ${e^{w_{1}X^{T}}+e^{w_{2}X^{T}}+e^{w_{3}X^{T}}}$ by ${S}$. Then, ${L\left(y^{h},\hat y\right) = -\log \left(\frac {e^{w_{2}X^{T}}}{S}\right) = \log {S}-{w_{2}X^{T}}}$&lt;/p&gt;
&lt;h3 id=&quot;Calculating-Loss-With-Label-Smoothing&quot;&gt;Calculating Loss With Label Smoothing&lt;a class=&quot;anchor-link&quot; href=&quot;#Calculating-Loss-With-Label-Smoothing&quot;&gt; &lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Our prediction vector is same as before, but our target vector changes. Let's denote our label smoothed target vector as ${y^{l}}$. So, ${y^{l} = [\frac {\varepsilon}{3}, 1-\varepsilon + \frac {\varepsilon}{3}, \frac {\varepsilon}{3}]^{T}}$. Then, our new loss will be ${L\left(y^{l},\hat y\right) = -\frac {\varepsilon}{3}\times \log\frac {e^{w_{1}X^{t}}}{S}-\left(1-\varepsilon+\frac{\varepsilon}{3}\right)\times \log\frac {e^{w_{2}X^{t}}}{S}-\frac {\varepsilon}{3}\times \log\frac {e^{w_{3}X^{t}}}{S}}$. Grouping the varibles appropriately,&lt;/p&gt;
&lt;p&gt;${L\left(y^{l},\hat y\right)= -\left(1-\varepsilon\right)\times \log\frac {e^{w_{2}X^{t}}}{S}-\frac {\varepsilon}{3}\times\left(\log\frac {e^{w_{1}X^{t}}}{S}+\log\frac {e^{w_{2}X^{t}}}{S}+\log\frac {e^{w_{3}X^{t}}}{S}\right)}$. Remember that ${\log a + \log b = \log ab}$. Utilising this rule, loss can be written as ${L\left(y^{l},\hat y\right)=\left(1-\varepsilon\right)\left(\log S-w_{2}X^{T}\right)-\frac{\varepsilon}{3}\times{\log\left(\frac{e^{w_{1}X^{T}+w_{2}X^{T}+w_{3}X^{T}}}{S^{3}}\right)}}$. To further reduce this equation, we need to know two more rules:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;${\log\frac{a}{b}=\log a-\log b}$ and &lt;/li&gt;
&lt;li&gt;${\log a^{b}=b\log a}$. &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Then, ${L\left(y^{l},\hat y\right)=\left(\log S-w_{2}X^{T}\right)-\varepsilon\left(\log S - w_{2}X^{T}\right)-\frac{\varepsilon}{3}\left(w_{1}X^{T}+w_{2}X^{T}+w_{3}X^{T}\right)+\frac{\varepsilon}{3}\log\left(S^{3}\right)}$.&lt;/p&gt;
&lt;p&gt;Expanding the second term in this expression and using rule 2 we get,
${L\left(y^{l},\hat y\right)=\left(\log S-w_{2}X^{T}\right)-\varepsilon\log S+\varepsilon\left(w_{2}X^{T}\right)-\frac{\varepsilon}{3}\left(w_{1}X^{T}+w_{2}X^{T}+w_{3}X^{T}\right)+{\varepsilon}\log\ S}$. Notice, that first term of the last expression is our ${L\left(y^{h},\hat y\right)}$. Therefore, our loss with smooth labels can be finally written as ${L\left(y^{l},\hat y\right)=L\left(y^{h},\hat y\right)+\frac{\varepsilon}{3}\left(2w_{2}X^{T}-w_{1}X^{T}-w_{3}X^{T}\right)}$.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;h2 id=&quot;4.-Geometric-Point-Of-View&quot;&gt;4. Geometric Point Of View&lt;a class=&quot;anchor-link&quot; href=&quot;#4.-Geometric-Point-Of-View&quot;&gt; &lt;/a&gt;&lt;/h2&gt;&lt;p&gt;(X -&amp;gt; Penultimate layer's activation)&lt;/p&gt;
&lt;p&gt;Our last layer's output for the image we input earlier is ${Z= \left[
         \begin{array}{ccc}
         w_{1}X^{T}          \\
         w_{2}X^{T}           \\
         w_{3}X^{T}
        \end{array}
    \right]}$. Since this image belongs to class 2, minimising any of the loss functions calculated above increases ${w_{2}X^{T}}$ while ${w_{1}X^{T}}$ and ${w_{3}X^{T}}$ are decreased. More generally, if an image belongs to class ${k}$ then in minimising the loss, ${z_{k}=w_{k}X^{T}}$ is increased while every other logit is decreased. Also, notice a pattern that ${w_{i}}$ produces logits for class ${i}$ using the operation ${w_{i}X^{T}}$. Hence, ${w_{i}}$ can be thought of as a template for class ${i}$. So,from now on I'll sometimes refer to ${w_{i}}$ as template for class ${i}$. Let's try to view the process of minimising or maximising ${w_{i}X^{T}}$ geometrically.&lt;/p&gt;
&lt;h4 id=&quot;Euclidean-Norm&quot;&gt;Euclidean Norm&lt;a class=&quot;anchor-link&quot; href=&quot;#Euclidean-Norm&quot;&gt; &lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Euclidean norm of two vectors is simply the distance between the two vectors in their space. Euclidean Norm for two vectors ${a}$ and ${b}$ can be calculated as: ${\lVert a-b\rVert=\left(a^{T}\star a-2a^{T}\star{b}+b^{T}\star b\right)^{\frac{1}{2}}}$. ${\therefore \lVert a-b\rVert^{2}= a^{T}\star a-2a^{T}\star{b}+b^{T}\star b}$. (Remeber that ${\star}$ denotes matrix multiplication.)&lt;/p&gt;
&lt;h4 id=&quot;Loss-Mimisation-as-Distance-Minimisation/Maximisation&quot;&gt;Loss Mimisation as Distance Minimisation/Maximisation&lt;a class=&quot;anchor-link&quot; href=&quot;#Loss-Mimisation-as-Distance-Minimisation/Maximisation&quot;&gt; &lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Now that we know how to calculate the euclidean norm, let's calculate it for ${w_{i}}$ and ${X}$. ${\lVert w_{i}-X\rVert^{2}= w_{i}^{T}\star w_{i}-2w_{i}^{T}\star{X}+X^{T}\star X= w_{i}^{T}\star w_{i}-2w_{i}{X}^{T}+X^{T}\star X}$. (For any two vectors ${a}$ and ${b}$, ${a\star b=a.b^{T}}$ where ${\star}$ and ${.}$ denote matrix multiplication and inner product respectively). Geometrically, this quantity is square of the distance between template for class ${i}$ and penultimate layer's activation ${X}$.&lt;/p&gt;
&lt;p&gt;Notice the second term inside the expression of ${\lVert w_{i}-X\rVert^{2}}$ which is ${2w_{i}X^{T}}$. If this term increases, the distance between ${w_{i}}$ and ${X}$ decreases and whenever it decreases the mentioned distance increases. But notice that this second term is just the same as ${2\times z_{i}}$. This means whenever ${z_{i}}$ increases/decreases, distance between ${w_{i}}$ i.e tempelate for class ${i}$ and ${X}$ i.e penultimate layer's output vector decreases/increases. If an image belongs to class ${k}$, minimising the loss increases ${z_{k}}$ and decreases every other logit. This means that minimising the loss is same as minimising the distance between penultimate layer's output ${X}$ and template for correct class ${w_{k}}$ and maximising the distance between ${X}$ and template for every incorrect class i.e ${w_{i}}$ where ${i \neq k}$.&lt;/p&gt;
&lt;p&gt;Thus, we can infer that minimising ${L\left(y^{h},Z\right)}$ or ${L\left(y^{l},Z\right)}$ produces the same effect which is to bring ${w_{k}}$ close to ${X}$ when image belongs to class ${k}$ and taking ${w_{i}}$ where ${i\neq k}$ far from ${X}$. The different performance of these two losses stem from the manner in which they go about doing this which is explained below.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;h2 id=&quot;5.-Derivatives-Of-Losses-Tell-The-Difference.&quot;&gt;5. Derivatives Of Losses Tell The Difference.&lt;a class=&quot;anchor-link&quot; href=&quot;#5.-Derivatives-Of-Losses-Tell-The-Difference.&quot;&gt; &lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Now let's, painstakingly write the two losses without any abridgement.&lt;/p&gt;
&lt;p&gt;${L\left(y^{h},\hat y\right)=\log\left(e^{w_{1}X^{T}}+e^{w_{2}X^{T}}+e^{w_{3}X^{T}}\right)-w_{2}X^{T}}$&lt;/p&gt;
&lt;p&gt;${L\left(y^{l},\hat y\right)= \log\left(e^{w_{1}X^{T}}+e^{w_{2}X^{T}}+e^{w_{3}X^{T}}\right)-w_{2}X^{T}+\frac{\varepsilon}{3}\left(2w_{2}X^{T}-w_{1}X^{T}-w_{3}X^{T}\right)}$.&lt;/p&gt;
&lt;p&gt;The reason we wrote the losses like this is because written this way, it'll be easy to take their derivatives w.r.t any term we want. We know that we minimise the loss using gradient descent. Imagine the loss surface as a convex surface (like a hollow ball cut in half and it's upper hemisphere removed). Our aim is to go to the lowest point in this convex region where the loss is lowest. We go to this point by continously changing our parameters using the gradient descent rules. Now, at this point we need to remember some rules from calculus.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Let's say there's a function ${f\left(x\right)}$. It's derivative w.r.t x, ${\normalsize\frac{df}{dx}}$ can be denoted as ${f'(x)}$. Notice that derivative is also a function of x. Suppose ${f\left(x\right)}$ is at it's minimum at point ${x^{\ast}}$. Then, ${f'(x^{\ast})=0}$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;${\normalsize\frac{d\log x}{dx}=\frac{1}{x}}$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Derivative-of-${L\left(y^{h},\hat-y\right)}$&quot;&gt;Derivative of ${L\left(y^{h},\hat y\right)}$&lt;a class=&quot;anchor-link&quot; href=&quot;#Derivative-of-${L\left(y^{h},\hat-y\right)}$&quot;&gt; &lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Let's imagine that we trained our model using the loss ${L\left(y^{h},\hat y\right)}$ and through meticulous training we have reached the minimum point on our loss surface i.e our loss is lowest it can be (Sadly, in practice this doesn't happen but we still assume this because by doing so we can infer how the parameters behave in order to reach the holy grail i.e global minima or a satisfactory local minima). The value of ${W}$ at minima is ${W^{\ast}=\left[
         \begin{array}{ccc}
         w_{1}^{\ast}          \\
         w_{2}^{\ast}          \\
         w_{3}^{\ast}
        \end{array}
    \right]}$.&lt;/p&gt;
&lt;p&gt;Now we take derivative of ${L\left(y^{h},\hat y\right)}$ w.r.t ${W}$. The derivative is written as ${L'_{h}\left(W\right)=\frac{\delta L_{h}}{\delta W}= \left[
         \begin{array}{ccc}
         \frac{\delta L_{h}}{\delta w_{1}}          \\
         \frac{\delta L_{h}}{\delta w_{2}}          \\
         \frac{\delta L_{h}}{\delta w_{3}}
        \end{array}
    \right]}$ (${L_{h}}\, denotes\, L\left(y^{h},\hat y\right) $). Since ${L_{h}}$ is composed of two variables ${X}$ and ${w_{i}}$, it's derivative w.r.t one of the variables is written with delta (${\delta}$) sign. This sign simply denotes that while taking derivative of a function w.r.t to a variable treat the other variable as constant. Since we are taking derivative w.r.t ${w_{i}}$ we will treat ${X}$ as constant.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;${\large\frac{\delta L_{h}}{\delta w_{1}}=\frac{e^{w_{1}X^{T}} X^{T}}{S}}$.&lt;/li&gt;
&lt;li&gt;${\large\frac{\delta L_{h}}{\delta w_{2}}=\frac{e^{w_{2}X^{T}} X^{T}}{S}-\normalsize X^{T}}$.&lt;/li&gt;
&lt;li&gt;${\large\frac{\delta L_{h}}{\delta w_{3}}=\frac{e^{w_{3}X^{T}} X^{T}}{S}}$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now from rules of calculus we know that ${\large\frac{\delta L_{h}}{\delta w_{1}}=\large\frac{\delta L_{h}}{\delta w_{2}}=\large\frac{\delta L_{h}}{\delta w_{3}}=\normalsize0}$ at ${W^{\ast}}$.&lt;/p&gt;
&lt;p&gt;${\therefore\large\frac{e^{w_{1}^{\ast}X^{T}} X^{T}}{S}=0 \implies e^{w_{1}^{\ast}X^{T}}=0\implies \normalsize w_{1}^{\ast}X^{T}=-\infty\,(Eq.1)}$. Similarly, ${\normalsize w_{3}^{\ast}X^{T}=-\infty\,(Eq.2)}$. The case is different with ${w_{2}}$ though because it is the tempelate corresponding to the correct class. ${\large\frac{e^{w_{2}^{\ast}X^{T}} X^{T}}{S}-\normalsize X^{T}=0\implies \frac{e^{w_{2}^{\ast}X^{T}}}{e^{w_{1}^{\ast}X^{T}}+e^{w_{2}^{\ast}X^{T}}+e^{w_{3}^{\ast}X^{T}}}=1}$ ${(Eq\,3)}$. ${(Eq\,3)}$ implies that ${w_{1}^{\ast}}$ and ${w_{3}^{\ast}}$ are negligible when compared to ${w_{2}^{\ast}}$. ${Eq.1}$ and ${Eq.2}$ show that ${L_{h}}$ is minimum when the distance between tempelate of incorrect labels ($w_{1}^{\ast}$,$w_{2}^{\ast}$) and ${X}$ is ${\infty}$.
From this we can infer the behaviour inflicted upon the weights connecting penultimate layer and Final Layer by reducing the loss ${L_{h}}$. Minimising this loss takes the weights corresponding to incorrect class away from penultimate layer's activations &lt;strong&gt;without any bounds&lt;/strong&gt;. i.e ${X}$ and the templates of incorrect classes really begin to hate each other and go as far away from each other as possible.&lt;/p&gt;
&lt;h3 id=&quot;Derivative-of-${L\left(y^{l},\hat-y\right)}$&quot;&gt;Derivative of ${L\left(y^{l},\hat y\right)}$&lt;a class=&quot;anchor-link&quot; href=&quot;#Derivative-of-${L\left(y^{l},\hat-y\right)}$&quot;&gt; &lt;/a&gt;&lt;/h3&gt;&lt;p&gt;This time we train the model using the loss ${L\left(y^{l},\hat y\right)}$ and again reach the impractical situation where we are at the global minimum or a satisfactory local minimum of the loss surface. The ${W}$ at this point is ${W^{\star}}$. Note that this ${W^{\star}}$ is different from ${W^{\star}}$ of previous subsection because our loss surface is different. (Apologies if you get confused due to notation. ${W}$ is a variable while ${W^{\star}}$ is a fixed value of that variable which occurs at minima).&lt;/p&gt;
&lt;p&gt;The derivative of loss w.r.t ${W}$ is given as ${L'_{l}\left(W\right)=\frac{\delta L_{l}}{\delta W}= \left[
         \begin{array}{ccc}
         \frac{\delta L_{l}}{\delta w_{1}}          \\
         \frac{\delta L_{l}}{\delta w_{2}}          \\
         \frac{\delta L_{l}}{\delta w_{3}}
        \end{array}
    \right]}$ (${L_{l}}\, denotes\, L\left(y^{l},\hat y\right)$).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;${\large\frac{\delta L_{l}}{\delta w_{1}}=\frac{e^{w_{1}X^{T}} X^{T}}{S}-\frac{\varepsilon}{3}\normalsize X^{T}}$.&lt;/li&gt;
&lt;li&gt;${\large\frac{\delta L_{l}}{\delta w_{2}}=\frac{e^{w_{2}X^{T}} X^{T}}{S}-\normalsize X^{T}+\large \frac {2\varepsilon X^{T}}{3}}$.&lt;/li&gt;
&lt;li&gt;${\large\frac{\delta L_{l}}{\delta w_{3}}=\frac{e^{w_{3}X^{T}} X^{T}}{S}-\frac{\varepsilon}{3}\normalsize X^{T}}$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We know that ${\large\frac{\delta L_{l}}{\delta w_{1}}=\large\frac{\delta L_{l}}{\delta w_{2}}=\large\frac{\delta L_{l}}{\delta w_{3}}=0}$ at ${W^{\star}}$.&lt;/p&gt;
&lt;p&gt;${\therefore \large\frac{e^{w_{1}^{\ast}X^{T}}X^{T}}{S}-\frac{\varepsilon X^{T}}{3}=0 \implies e^{w_{1}^{\ast}X^{T}}=\frac{S\large\varepsilon}{3}\implies \normalsize w_{1}^{\ast}X^{T}=\log \frac{\normalsize S\varepsilon}{3}}$ ${(Eq.3)}$. Similarly, ${\normalsize w_{3}^{\ast}X^{T}}=\large\log \frac{S\varepsilon}{3}$ ${(Eq.4)}$. In case of  ${\large\frac{\delta L_{l}}{\delta w_{2}}}$, ${\large\frac {e^{w_{2}^{\ast}X^{T}}X^{T}}{S}-\normalsize X^{T}+\large\frac {2\varepsilon X^{T}}{3} =0\implies \large e^{w_{2}^{\ast}X^{T}}= \normalsize S(1-\frac{2\varepsilon}{3})}$ ${(Eq.5)}$.&lt;/p&gt;
&lt;p&gt;To interpret ${Eq.5}$ let's put in the value of ${\varepsilon}$. Generally, ${\varepsilon}$ is taken as 0.1. Putting that in ${Eq.5}$, ${\large e^{w_{2}^{\ast}X^{T}}= \normalsize S(\frac{2.8}{3})=\normalsize0.93(e^{w_{1}^{\ast}X^{T}}+e^{w_{2}^{\ast}X^{T}}+e^{w_{3}^{\ast}X^{T}})\implies 0.07(e^{w_{2}^{\ast}X^{T}})=e^{w_{1}^{\ast}X^{T}}+e^{w_{3}^{\ast}X^{T}}}$. This shows that ${w_{2}^{\ast}X^{T}}$ is still large compared to  ${w_{1}^{\ast}X^{T}}$ and  ${w_{3}^{\ast}X^{T}}$. But there's one thing different, ${Eq.3}$ and ${Eq.4}$ show that at optimal point ${w_{1}^{\ast}X^{T}}$ and ${w_{3}^{\ast}X^{T}}$ are not ${-\infty}$ but a finite quantity i.e ${\normalsize\log \frac{S\varepsilon}{3}}$. This shows that minimising ${L_{l}}$ doesn't decrease ${w_{1}^{\ast}X^{T}}$ and ${w_{3}^{\ast}X^{T}}$ without any bounds, but decreases them upto a certain point which is same for ${w_{1}^{\ast}X^{T}}$ and ${w_{3}^{\ast}X^{T}}$.  We can see that ${X}$ is equidistant from both ${w_{1}^{\ast}}$ and ${w_{3}^{\ast}}$.&lt;/p&gt;
&lt;p&gt;Geometrically, we can say that minimising ${L_{l}}$ decreases the distance between tempelate of correct class and penultimate layer's activation (${X}$), and also encourages ${X}$ to go far from tempelates of incorrect classes but also remain equidistant from them. In this case ${X}$ hates the templates of incorrect classes but not as much as the ${X}$ of the previous subsection. Also, it hates all the incorrect class templates equally and tries to remain equidistant from them. The ${X}$ and template of correct class in this section love each other but not as strongly as those of previous section. (Apologies for the cheesy interpretation)&lt;/p&gt;
&lt;p&gt;So this is where ${L_{l}}$ is different from ${L_{h}}$.&lt;/p&gt;
&lt;p&gt;I hope now you can make sense of the main statement of the paper by Rafael MÃ¼ller et.al which I quote verbatim: &lt;strong&gt;&quot;label smoothing encourages the activations of the penultimate layer to be close to the template of the correct class and equally distant to the templates of the incorrect classes.&quot;&lt;/strong&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;h2 id=&quot;6.-Okay,-So-How-Does-It-Help-My-Model?&quot;&gt;6. Okay, So How Does It Help My Model?&lt;a class=&quot;anchor-link&quot; href=&quot;#6.-Okay,-So-How-Does-It-Help-My-Model?&quot;&gt; &lt;/a&gt;&lt;/h2&gt;&lt;p&gt;(In this section ${Xi}$ will denote the penultimate layer's activation when an image belonging to class ${i}$ is input in the model.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;${L_{h}}$ = Loss calculated with one-hot encoded target vectors&lt;/li&gt;
&lt;li&gt;${L_{l}}$ = Loss calculated with target vectors with smooth labels&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let's go with the above scenario that we have a task of image classifiaction where a given image can belong to 3 classes. Suppose that class1 and class2 among these are symantically very similar (for.eg toy poodle and miniature poodle class of &lt;a href=&quot;http://www.image-net.org/&quot;&gt;ImageNet&lt;/a&gt;). This means that if you input an image belonging to class1 and another image belonging to class2, their penultimate layer's activation can be very similar. Now, you prepare your dataset but you unfortunately forget to shuffle it randomly and so, all the images belonging to class1 are placed before all the images of class2 in the dataset. You begin training on this dataset by using a suitable batch size and using the loss ${L_{h}}$. By the time a batch of images belonging to class2 goes inside your model, the model has already been partially tuned by class1 images. Since you are training with ${L_{h}}$ loss, the ${X1}$ which derive from images of class1 have been dragged extremely far away from template of class2 and class3. Now, a batch of images belonging to class2 goes inside the model. Since class2 is symantically similar to class1, images belonging to this class have their penultimate layer's activation ${X2}$ very similar to ${X1}$. Because of this, these images will show a very strong affinity for class1 and despise being predicted that they belong to class2 because ${w_{1}(X2)^{T}}$ will be high for these images and at same time ${w_{2}(X2)^{T}}$ will be low. This will incur large value of loss which is bad for model. To remedy this, the model will need to take large steps and will take longer time to reduce the huge loss value. Instead, if we had trained on ${L_{l}}$, our model wouldn't have to work as hard to adapt since model itself is not entirely confident that if penultimate layer's activation are similar to ${X1}$ then the label is class1. Since ${w_{2}}$ is not dragged too far away from ${X1}$ and thus consequently ${X2}$ , the loss wouldn't be as high as in the previous case and the model will have the ability to adapt quickly. (Maybe this example also shows the importance of randomly shuffling your data).&lt;/p&gt;
&lt;p&gt;Another advantage is incurred in classification. Suppose that this time learning from our previous mistake we shuffled the data randomly but trained the model with loss ${L_{h}}$. Since images belonging to class1 and class2 are very similar, both ${X1}$ and ${X2}$ are close to both ${w_{1}}$ and ${w_{2}}$. Also both (${X1}$) and (${X2}$) are far away from ${w_{3}}$. Although this model will accurately differentiate between class1 and class3 or class2 and class3,it may also sometimes misclassify images, if the image belonging to class1 or class2 is fed into the model. Because their ${X's}$ are so similar, model may assign class2 to an image belonging to class1 or vice versa.
But instead if we train with ${L_{l}}$ loss, ${X1}$ will be equidistant from ${w_{2}}$ and ${w_{3}}$. Similarly,  ${X2}$ will be equidistant from ${w_{1}}$ and ${w_{3}}$. Then, if we put an image belonging to class2 and it produces ${X2}$ from it's penultimate layer, model will correctly assign it class2 and will not confuse it with class1. (If distance of ${X2}$ from ${w_{1}}$ and ${w_{3}}$ is sufficiently large).&lt;/p&gt;
&lt;p&gt;Sometimes, during our data labelling process, some images may get incorrect labels due to human error or other factors. In that case you don't want the penultimate layer activations of your images to cling too tightly to template of incorrectly labelled class, which would inevitably happen if you use ${L_{h}}$ loss. To make the modul robust against these incorrect labels, Label smoothing can come in handy because it decreases the model's confidence in it's incorrect ground-truth labels and doesn't let the ${X's}$ of images get too close to their incorrect label templates. Even though ${X}$ will get close to the tempelate of it's incorrect labels, it would be easier to modify if model is trained with ${L_{l}}$ instead of ${L_{h}}$.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;h2 id=&quot;7.-Conclusion&quot;&gt;7. Conclusion&lt;a class=&quot;anchor-link&quot; href=&quot;#7.-Conclusion&quot;&gt; &lt;/a&gt;&lt;/h2&gt;&lt;p&gt;We may conclude that if our dataset has symantically different classes and is correctly labelled (for.eg &lt;a href=&quot;https://github.com/fastai/imagenette&quot;&gt;Imagenette dataset&lt;/a&gt; by fastai), then our normal loss function may perform well. But if it has symantically similar classes (for.eg &lt;a href=&quot;https://github.com/fastai/imagenette#imagewoof&quot;&gt;Imagewoof dataset&lt;/a&gt; by fastai) or has incorrect labels, then you may want to use Label Smoothing.(Also, don't forget to randomly shuffle your data ;).&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;p&gt;&lt;em&gt;If you notice a mistake in this blog post please mention them in the comment section or email them to me at iamabhimanyu08@gmail.com, I'll make sure to correct them right away.&lt;/em&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://abhimanyu08.github.io/blog/images/ls.JPG" /><media:content medium="image" url="https://abhimanyu08.github.io/blog/images/ls.JPG" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Bayesâ Theorem</title><link href="https://abhimanyu08.github.io/blog/probability-theory/2020/03/23/final.html" rel="alternate" type="text/html" title="Bayes' Theorem" /><published>2020-03-23T00:00:00-05:00</published><updated>2020-03-23T00:00:00-05:00</updated><id>https://abhimanyu08.github.io/blog/probability-theory/2020/03/23/final</id><content type="html" xml:base="https://abhimanyu08.github.io/blog/probability-theory/2020/03/23/final.html">&lt;!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2020-03-23-final.ipynb
--&gt;

&lt;div class=&quot;container&quot; id=&quot;notebook-container&quot;&gt;
        
    
    
&lt;div class=&quot;cell border-box-sizing code_cell rendered&quot;&gt;

&lt;/div&gt;
    

&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;h2 id=&quot;1.-Notations&quot;&gt;1. Notations&lt;a class=&quot;anchor-link&quot; href=&quot;#1.-Notations&quot;&gt; &lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;P(X)&lt;/strong&gt; = Probality of event X.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P(X|Y)&lt;/strong&gt; = Probability of X given that Y has occured.&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;h2 id=&quot;2.-Pre-requisites&quot;&gt;2. Pre-requisites&lt;a class=&quot;anchor-link&quot; href=&quot;#2.-Pre-requisites&quot;&gt; &lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;You need to have knowledge of basic probability theory. If you are comfortable in calculating probabilities of discrete events and comfortable with the sum rule and product rule then you're good to go (If you're not, don't worry, I've tried to give a terse explaination using an example below). Try out this question.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Que&lt;/strong&gt; - Bag A has 5 red and 3 blue balls, Bag B has 6 red and 4 blue balls. The probability that a person chooses Bag A is 0.3 and he'll choose Bag B with probability 0.7. What is the probability of a person selecting a blue ball from bag B? What is the total probability of him coming out with a red ball?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ans&lt;/strong&gt; -&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Probability of choosing blue ball from B = (He chooses B) and (and then he selected blue ball from B)&lt;/em&gt; i.e ${P(B)\times P(blue\mid B)}$. If your answer is 0.28, then you're comfortable with the product rule.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Probability of him coming out with a red ball = (He chooses red ball from A) or (he chooses red ball from B)&lt;/em&gt; i.e ${P(A)\times P(red\mid A)+ P(B)\times P(red\mid B)}$. If your answer comes out to be 0.6075, then you're comfortable with the sum rule.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Intuitively, sum rule comes in play when there is a choice between mutually exclusive events  (these events are generally seperated by a &lt;strong&gt;or&lt;/strong&gt; between them) for eg. The event of (either choosing A and then a red ball) &lt;strong&gt;or&lt;/strong&gt; (B and then a red ball) (as shown in second bullet point above). Product rule comes into play when two events occur simultaneously for eg. choosing bag B &lt;strong&gt;and&lt;/strong&gt; then selecting a blue ball from it (as shown in first bullet point above).&lt;/em&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;h2 id=&quot;3.-Formula-and-basic-jargon&quot;&gt;3. Formula and basic jargon&lt;a class=&quot;anchor-link&quot; href=&quot;#3.-Formula-and-basic-jargon&quot;&gt; &lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Let me state the formula for Bayes' theorem quickly. Subsequently, I'll explain every term of the formula in detail using an example and introduce some basic jargon along the way.&lt;/p&gt;
&lt;p&gt;${\displaystyle \large P(A\mid B)={\frac {P(B\mid A)P(A)}{P(B)}}}$   (3.0)&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;p&gt;Let's try to understand this formula by investigating a theft incidence.&lt;/p&gt;
&lt;p&gt;There are two secret vaults A and B. Vault A contains 6 gold bars and 2 diamonds. Vault B contains 2 gold bars and 8 diamonds. Vault A is easier to break open and therefore if a thief encounters both vaults he's more likely to break into A than in B. Let's say a thief will break in A with probability 0.7 and in B with probability 0.3. Unfortunately, despite all the security, a theft occurs. Due to security alarms, thief had to rush and could only take whichever piece of ornament he could get his hands on (In other words, he didn't have the time to think that diamond is more precious so I should pick diamond instead of gold). After the heroic efforts of the police, the thief is caught and he's found having a diamond. You are a detective but like Sherlock Holmes, unauthorised. You have a personal history with the thief and want to get some more lead into this case by knowing from which vault the theft occured. Sadly, being unauthorised, you're not allowed to enter the crime scene. Thus, you would have to guess the vault from which the thief has stolen the diamond? Let's say you hypothesise that he must have stolen from A because it was easier to break into. Subsequently, you go home and then sit down with a pen and paper to test the validity of your hypothesis using the Bayes' theorem&lt;/p&gt;
&lt;p&gt;Let us define some symbols first,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;${P(A)}$ = probability of breaking into A which is given as 0.7.&lt;/li&gt;
&lt;li&gt;${P(B)}$ = probability of breaking into B which is given as 0.3.&lt;/li&gt;
&lt;li&gt;${P(G)}$ = probability of stealing the gold bar.&lt;/li&gt;
&lt;li&gt;${P(D)}$ = probability of stealing the diamond.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You have to compute probability of thief having broken into A &lt;strong&gt;given that&lt;/strong&gt; diamond was found in his hand i.e ${P(A\mid D)}$.
Expanding this term using the formula 3.0 gives us:
                      ${\displaystyle P(A\mid D)={\frac {P(D\mid A)P(A)}{P(D)}}}$   (3.1)&lt;/p&gt;
&lt;p&gt;The sentence &quot;The thief was found having a diamond&quot; is called &lt;strong&gt;Evidence&lt;/strong&gt;. Probability of finding the &lt;strong&gt;Evidence&lt;/strong&gt; is written mathematically as ${P(D)}$ which is the denominator of our Eq.3.1.
To solve the question, we begin by listing all the ways through which &lt;strong&gt;Evidence&lt;/strong&gt; could have occured. There are two cases in which diamond could've been stolen:-&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;He broke into A &lt;strong&gt;and&lt;/strong&gt; then picked up a diamond i.e ${P(A)\times P(D\mid A)}$ &lt;strong&gt;or&lt;/strong&gt;  2. He broke into B &lt;strong&gt;and&lt;/strong&gt; then picked up a diamond i.e ${P(B)\times P(D\mid B)}$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;All these listed ways make up your ${P(D)}$ in Eq.3.1. Thus ${P(D)}$ written mathematically will be equal to -&amp;gt;
                       ${P(A)\times P(D\mid A) + P(B)\times P(D\mid B)}$ (3.2)&lt;/p&gt;
&lt;p&gt;Now, You will write down your &lt;strong&gt;Prior&lt;/strong&gt; belief in the correctness of your hypothesis &lt;strong&gt;if you had not seen&lt;/strong&gt; the &lt;strong&gt;evidence&lt;/strong&gt;. What are the odds that thief broke into A? The odds are simply ${P(A)}$ or 0.7. Thus, ${P(A)}$ is called &lt;strong&gt;Prior&lt;/strong&gt;, because it reflects your &lt;em&gt;prior belief&lt;/em&gt; about the correctness of your hypothesis &lt;em&gt;before seeing the&lt;/em&gt; &lt;strong&gt;Evidence&lt;/strong&gt;.
Now, what are the chances that he stole the diamond &lt;strong&gt;given that&lt;/strong&gt; he infiltrated A? In other words,what are the chances of seeing the &lt;strong&gt;Evidence&lt;/strong&gt; given that your hypothesis is true? Mathematically speaking, ${P(D\mid A)}$. This entity is called &lt;strong&gt;Likelihood&lt;/strong&gt;. Likelihood can be described as answer to the question &quot;How likely is that evidence occurs if I assume my hypothesis is true?&quot;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Likelihood&lt;/strong&gt; and &lt;strong&gt;Prior&lt;/strong&gt; make up the numerator in (3.1). Thus your numerator is 
                                             ${P(A)\times P(D\mid A)}$. (3.3)&lt;/p&gt;
&lt;p&gt;Why is the entity (3.3) our numerator and why not anything else? If you notice carefully (3.3) is probability of our case no 1 (He broke into A &lt;strong&gt;and&lt;/strong&gt; then picked up a diamond).
Intuitively, we can think of it as following:-
Out of all the cases that make up your evidence ${P(D)}$ you are only interested in the ones in which your hypothesis holds true. Thus only the case no 1 from above list of cases interests you and you put that in your numerator. And if you remember, that is basic probability; we calculate probability using the formula -&amp;gt; &lt;strong&gt;cases that interest us/total no of cases&lt;/strong&gt;, for eg. What are the odds of selecting a red card from a deck of cards -&amp;gt; 26/52 or 0.5.&lt;/p&gt;
&lt;p&gt;Thus,finally after putting all the pieces together we can calculate&lt;/p&gt;
&lt;p&gt;${\displaystyle P(A\mid D) = {\frac {P(A)\times P(D\mid A)}{P(D)}} = {\displaystyle \frac {Equation 3.3}{Equation 3.2}} = {\frac {P(A)\times P(D\mid A)}{P(A)\times P(D\mid A) + P(B)\times P(D\mid B)}} =  0.42}$&lt;/p&gt;
&lt;p&gt;The chances that your hypothesis is true is 42%. Put in other words, the chances of your hypothesis being wrong are 58%. Hence,it is more likely that he broke into B and not A! Now, reflecting on the details of the theft, you suddenly realise that &quot;Ah! That makes sense. There are more diamonds in B than in A and the thief hurriedly picked up whatever ornament he could get his hands on and got diamond. Thus,if he broke into B he had more chances of picking a diamond blindly than doing so after breaking into A. So he must have stolen from B&quot;
The calculated probability &lt;strong&gt;${P(A\mid D)}$&lt;/strong&gt; is called the &lt;strong&gt;Posterior&lt;/strong&gt;. This probability is an updated version of our &lt;strong&gt;Prior&lt;/strong&gt; based on new &lt;strong&gt;evidence&lt;/strong&gt;. Now that we found the evidence that thief had a diamond, we believe that he broke into A with probability 0.42 (&lt;strong&gt;posterior&lt;/strong&gt;) instead of 0.7 (&lt;strong&gt;prior&lt;/strong&gt;). In other words your belief in your hypothesis went down in the light of new evidence. This is the main motive of Bayes' theorem, It helps us update our &lt;strong&gt;Prior&lt;/strong&gt; beliefs continuously by collecting new &lt;strong&gt;Evidence&lt;/strong&gt;.&lt;/p&gt;
&lt;h4 id=&quot;Quick-summary-and-technique-to-solve-problems-involving-Bayes'-Theorem-:&quot;&gt;Quick summary and technique to solve problems involving Bayes' Theorem :&lt;a class=&quot;anchor-link&quot; href=&quot;#Quick-summary-and-technique-to-solve-problems-involving-Bayes'-Theorem-:&quot;&gt; &lt;/a&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Find out what is &lt;strong&gt;given&lt;/strong&gt; in the problem. The given part serves as &lt;strong&gt;Evidence&lt;/strong&gt; which aids us in assessing our &lt;strong&gt;Hypothesis&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;List out all the ways in which &lt;strong&gt;Evidence&lt;/strong&gt; could have occured, calculate the probabilities of those ways using product rule and sum rule and write them as denominator.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pick out the way amongst the list of ways in which your &lt;strong&gt;Hypothesis&lt;/strong&gt; holds true and put the probability of that in the numerator.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;h2 id=&quot;4.-Interesting-Study-Demonstrating-The-Counter-Intuitiveness-Of-The-Bayes'-Theorem&quot;&gt;4. Interesting Study Demonstrating The Counter-Intuitiveness Of The Bayes' Theorem&lt;a class=&quot;anchor-link&quot; href=&quot;#4.-Interesting-Study-Demonstrating-The-Counter-Intuitiveness-Of-The-Bayes'-Theorem&quot;&gt; &lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;em&gt;(This part of blog is inspired from a great video by &lt;a href=&quot;https://youtu.be/HZGCoVF3YvM&quot;&gt;3 Blue 1 Brown&lt;/a&gt;).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Let me ask you an interesting question.
&lt;strong&gt;Steve is very shy and withdrawn, invariably helpful but with little interest in people or in the world of reality. A meek and tidy soul, he has a need for order and structure, and a passion for detail.&quot;&lt;/strong&gt; Having read this sentence what do you think is the profession of Steve, a &lt;em&gt;librarian&lt;/em&gt; or a &lt;em&gt;farmer&lt;/em&gt; ?&lt;/p&gt;
&lt;p&gt;(&lt;em&gt;This quesion was asked by Nobel Laureate &lt;a href=&quot;https://en.wikipedia.org/wiki/Daniel_Kahneman&quot;&gt;Daniel Kahneman&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Amos_Tversky&quot;&gt;Amos Tversky&lt;/a&gt; in the studies which they conducted that showed that humans are intuitively bad staticians (even those who had PhDs in the field of statistics) and sometimes overestimate the correctness of their prior beliefs. Daniel Kahneman has written about these studies in his book &quot;Thinking ,fast and slow&quot;.&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;Most people would guess that Steve is a librarian because he fits in the stereotypical image of one. Let's look at this problem with a Bayesian perspective. Let's say that the sentence written in bold above is our &lt;strong&gt;evidence&lt;/strong&gt;. Now we &lt;strong&gt;hypothesise&lt;/strong&gt; that &lt;em&gt;Steve is a librarian&lt;/em&gt;. Let's calculate the validity of our hypothesis.&lt;/p&gt;
&lt;p&gt;Steve is a random person taken from a representative sample.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Let's say the probability of observing the above traits in a random person are ${P(E)}$.&lt;/li&gt;
&lt;li&gt;Let the probability of a random person being a farmer be ${P(F)}$.&lt;/li&gt;
&lt;li&gt;Let the probability of a random person being a librarian be ${P(L)}$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We would have to consider following questions to calculate the probability of our hypothesis given the evidence :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Out of 100 librarians how many do you think fit the description given above in bold typeface? We are allowed to incorporate our stereotypes in estimating the answer to this question. Let's say 85 out of 100 librarians fit the evidence. Mathematically speaking, &lt;strong&gt;given that&lt;/strong&gt; a person is a librarian, the probability of him fiiting the above evidence (he is shy and a &quot;meek and tidy soul&quot;) is  ${P(E\mid L)}$ = 0.85&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Out of 100 farmers how many do you think fit the description given above in bold typeface? Let's say 30 farmers fit the evidence (beacuse we all stereotypically think that farmers are less likely to be shy or a &quot;meek and tidy soul&quot;). Mathematically speaking, &lt;strong&gt;given that&lt;/strong&gt; a person is a farmer, the probability of him fiting the above evidence is ${P(E\mid F)}$ = 0.3&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We also need to take into account some statistical facts to decide our prior beliefs. At the time of conduction of this study, there were 20 farmers for every 1 librarian in america. Thus, out of 210, 10 people were librarian and 200 are farmers.Therefore, probability of a random person being a farmer i.e ${P(F)}$ = 0.95 and probability of a random person being a librarian i.e ${P(L)}$ is 0.05 (assuming our representative sample has only farmers and librarians).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Listing all the ways in which the evidence can occur:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The person selected at random is a librarian &lt;strong&gt;and&lt;/strong&gt; he is a &quot;meek and tidy soul&quot; (${P(L)\times P(E\mid L)}$) &lt;strong&gt;or&lt;/strong&gt; 2. The person selected at random is a farmer &lt;strong&gt;and&lt;/strong&gt; he is a &quot;meek and tidy soul&quot; (${P(F)\times P(E\mid F)}$).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Writing this mathematically -&amp;gt; &lt;strong&gt;${P(E) = P(L)\times P(E\mid L) + P(F)\times P(E\mid F)}$&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The case which interests us is case 1. Thus, &lt;strong&gt;${\displaystyle P(L\mid E) = \frac{P(L)\times P(E\mid L)}{P(L)\times P(E\mid L) + P(F)\times P(E\mid F)}}$&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;After doing the above calculation we find out that probability of Steve being a librarian is a mere 13 %. In other words, if you assemble 100 meek and tidy souls like Steve only 13 of them would turn out to be librarians. This seems surprising and counter-intuitive because we incorporated our stereotypes in our calculations (by saying that 85 out of 100 librarians fit the evidence), yet the final calculations conclude that our hypothesis (which complied with our stereotypes) was wrong.&lt;/p&gt;
&lt;p&gt;An intutive way of thinking about this is as following:&lt;/p&gt;
&lt;p&gt;There are way more farmers in general population than librarians, therefore there are way more &quot;meek and tidy souls&quot; ploughing the fields (77 out of 100 as per our calculations) than those who are meticulously keeping the books in the library. Take a sample of 210 people for example out of which 10 are librarians and 200 are farmers. According to our stereotypical estimates 85% of 10 librarians or ~9 librarians are shy, while only 30% of 200 lirarians or ~60 farmers are shy.Hence,out of 210 people 69 people are shy and tidy souls, majority of which are farmers. Thus, if we randomly picked a guy named Steve and he comes out as shy, he probably belongs to the group of 60 farmers.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;h2 id=&quot;5.-Bayes'-Theorem-As-A-Way-Of-Updating-Our-Priors-And-Belief-Systems.&quot;&gt;5. Bayes' Theorem As A Way Of Updating Our Priors And Belief Systems.&lt;a class=&quot;anchor-link&quot; href=&quot;#5.-Bayes'-Theorem-As-A-Way-Of-Updating-Our-Priors-And-Belief-Systems.&quot;&gt; &lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;em&gt;(This part of blog is inspired from this great video by &lt;a href=&quot;https://youtu.be/R13BD8qKeTg&quot;&gt;Veritasium&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Suppose, you go to a doctor and he tells you that results of your test for a disease are unfortunately positive. It is known that 0.1% of the population might have the disease. You know that the tests you took give correct results 99% of the time. Thus, you may be disheartened because such an accurate test has declared you of being sick from a rare disease. Intuitively, you would think that there is a 99% chance of you having this disease. But, let's look at this from a bayesian perspective.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Evidence&lt;/strong&gt; -&amp;gt; The test shows positive. ${P(E)}$ = 0.99&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hypothesis&lt;/strong&gt; -&amp;gt; You have the disease &lt;strong&gt;given&lt;/strong&gt; the evidence. ${P(D\mid E)}$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Prior belief before seeing the evidence&lt;/strong&gt; -&amp;gt; Probaility of you having the disease before you went for tests. ${P(D)}$ = 0.001 (because 0.1% of the population has it and you're part of the population)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Ways In Which Evidence Can Be Observed (Test result Can Come Out As Positive)&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;You have the disease &lt;strong&gt;and&lt;/strong&gt; test comes as positive (${P(D)\times P(E\mid D)}$). &lt;strong&gt;or&lt;/strong&gt; 2. You don't have the disease &lt;strong&gt;and&lt;/strong&gt; test shows positive (incorrectly) (${P(\neg D).P(E\mid \neg D)}$).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Mathematically -&amp;gt; &lt;strong&gt;${P(D) = P(D)\times P(E\mid D) + P(\neg D).P(E\mid \neg D)}$&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We are interested in case 1.&lt;/p&gt;
&lt;p&gt;Thus, probability of you having the disease &lt;strong&gt;given&lt;/strong&gt; positive test results ${P(D\mid E)}$ = ${\displaystyle \frac {P(D)\times P(E\mid D)}{P(D)\times P(E\mid D) + P(\neg D)\times P(E\mid \neg D)}}$.&lt;/p&gt;
&lt;p&gt;After calculations, the probability of you having the disease comes out to be a mere 9%, which again seems counter-intuitive. Even after being declared positive by a pretty accurate test you are probably healthy and test is False!&lt;/p&gt;
&lt;p&gt;This counter-intuitive result stems from the fact that probability of our &lt;strong&gt;hypothesis given the evidence&lt;/strong&gt; is directly proportional to our &lt;strong&gt;prior&lt;/strong&gt; i.e probability of our hypothesis being correct without the evidence (${P(D)}$ in above calculation). In this particular example, the probability of us having the disease without having the test results in our hand was so low (0.001) that even the new strong evidence couldn't vote in favour of our hypothesis that we have the disease.&lt;/p&gt;
&lt;p&gt;Think of just 1000 people which also includes you. According to given data, 1 out of these 1000 is sick from the disease. Let's say that he goes for the test and is correctly identified as positive. The other 999 also go for tests. The test will falsely identify 1% of 999 healthy people, i.e 10 healthy people are shown positive. So now, there are 11 people in entire population with positive test results and you are one of them. Out of these 11 positive test results only 1 is correct. That's why having a positive result in first trial is not as bad as you might think!&lt;/p&gt;
&lt;h3 id=&quot;But-What-If-You-Took-A-Second-Test-And-It-Comes-As-Positive&quot;&gt;But What If You Took A Second Test And It Comes As Positive&lt;a class=&quot;anchor-link&quot; href=&quot;#But-What-If-You-Took-A-Second-Test-And-It-Comes-As-Positive&quot;&gt; &lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Suppose just to be sure, you go through tests from a different lab and the result again comes out as positive (assuming that this lab also gives correct results 99% of the times). Now, what are the chances that you have the disease. Let's agai hypothesise that you have the disease and test the validity of out hypothesis. Everything remains the same in terms of data except the &lt;strong&gt;prior&lt;/strong&gt;. The basic definition of the prior is &lt;strong&gt;&quot;Probability that your hypothesis is true before collecting the evidence&quot;&lt;/strong&gt;. Thus, in this case the &lt;strong&gt;prior&lt;/strong&gt; is probability of you having the disease without having seen the results from second test. Therefore, prior should be 9% or 0.09 for the second case (&lt;strong&gt;Posterior&lt;/strong&gt; from the first test). Even though the earlier test was likely to be false, it served us by updating our &lt;strong&gt;prior&lt;/strong&gt; from 0.001 to 0.09 by providing us with a strong evidence.&lt;/p&gt;
&lt;p&gt;The probability of having the disease &lt;strong&gt;given&lt;/strong&gt; that second test result is also positive = 
${\displaystyle \frac {0.99\times 0.09}{0.99\times 0.09 + 0.01\times 0.91}}$ = ${91 \%}$.&lt;/p&gt;
&lt;p&gt;Thus, now you have 91% chances of being sick and intuitively this makes sense because the chances of two such accurate tests showing false results are pretty low.&lt;/p&gt;
&lt;p&gt;You had a hypothesis that you are sick with 0.1 % odds. Then, you collected a evidence by going through a test and that evidence updated your belief in your hypothesis to 9%. Subsequently, you went out to collect another evidence by going through another test. That test further updated your belief in hypothesis to 91%.&lt;/p&gt;
&lt;p&gt;This case shows that Bayes' theorem serves us by updating our priors with help of new evidences. The posteriors serve as priors for the next time any evidence is collected. This process iteratively helps in scientifically solidifying or falsifying our hypotheses by regularly collecting new evidences and updating our Priors subsequently.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;p&gt;&lt;em&gt;If you notice a mistake in this blog post please mention them in the comment section or email them to me at iamabhimanyu08@gmail.com, I'll make sure to correct them right away.&lt;/em&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://abhimanyu08.github.io/blog/images/1.jpg" /><media:content medium="image" url="https://abhimanyu08.github.io/blog/images/1.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>